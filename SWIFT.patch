From 2a88d054e6d38f3eb090d3f64742144372d5af12 Mon Sep 17 00:00:00 2001
From: bkoh-27 <ohboonkiat@gmail.com>
Date: Mon, 23 Feb 2026 22:28:56 +0900
Subject: [PATCH] For SWIFT implementation

---
 GalCenter/galcenter.c          |   9 +++
 NewDD/Makefile                 |  22 ++---
 NewDD/SWIFT.md                 |  86 ++++++++++++++++++++
 NewDD/newdd.c                  |  45 ++++++++---
 NewDD/rd_gadget.c              | 143 ++++++++++++++++++++++++++++-----
 NewDD/rd_gadget.h              |  28 +++++++
 NewGalFinder/Makefile          |   2 +-
 NewGalFinder/gfind.c           |  24 +++++-
 NewGalFinder/subhaloden.mod6.c |  42 ++++++----
 NewGalFinder/tree.h            |   2 +-
 opFoF/Rules.make               |   8 +-
 opFoF/Treewalk.fof.ordered.c   |  11 ++-
 opFoF/fof.h                    |   6 +-
 opFoF/opfof.c                  |  13 +++
 ramses.h                       |   7 +-
 15 files changed, 367 insertions(+), 81 deletions(-)
 create mode 100644 NewDD/SWIFT.md
 create mode 100644 NewDD/rd_gadget.h

diff --git a/GalCenter/galcenter.c b/GalCenter/galcenter.c
index 786a888..ede22a2 100755
--- a/GalCenter/galcenter.c
+++ b/GalCenter/galcenter.c
@@ -17,6 +17,11 @@
 #include "hfind.h"
 #include "galcenter.h"
 
+#define REQUIRED_OMEGA_M 0.3f
+#define REQUIRED_OMEGA_B 0.049f
+#define REQUIRED_H0 67.11f
+#define REQUIRED_OMEGA_L 0.7f
+
 FoFTPtlStruct *rbuffer;
 
 
@@ -208,6 +213,10 @@ int main(int argc, char *argv[]) {
 			fread(&omep,sizeof(float),1,rhfp);
 			fread(&omepb,sizeof(float),1,rhfp);
 			fread(&omeplam,sizeof(float),1,rhfp);
+			omep = REQUIRED_OMEGA_M;
+			omepb = REQUIRED_OMEGA_B;
+			omeplam = REQUIRED_OMEGA_L;
+			hubble = REQUIRED_H0;
 			fread(&amax,sizeof(float),1,rhfp);
 			fread(&anow,sizeof(float),1,rhfp);
 			ng = nx;
diff --git a/NewDD/Makefile b/NewDD/Makefile
index 770fb87..78de2d0 100755
--- a/NewDD/Makefile
+++ b/NewDD/Makefile
@@ -7,9 +7,7 @@
 # Compiler settings (configured by ../configure)
 #--------------------------------------------------
 CC = mpiicx
-OPT = -g -DNENER=0 -DNPRE=8 -DNMEG=20000 -DWGROUPSIZE=5  -DUSE_MPI -DQUADHILBERT -DREAD_SINK -DNCHEM=9 -DNDUST=4 -DDEBUG=1 -DLOG=1
-FORMAT_OPT ?=
-OPT += $(FORMAT_OPT)
+OPT = -g -DNENER=0 -DNPRE=8 -DNMEG=20000 -DWGROUPSIZE=5  -DUSE_MPI -DQUADHILBERT -DREAD_SINK -DNCHEM=9 -DNDUST=4 -DDEBUG=1 -DLOG=1 -DGADGET_HDF5
 
 RANLIB = ranlib
 
@@ -18,20 +16,15 @@ CCLAGS = $(OPT)
 
 LIBS       = libmyram.a
 
-TIMEROBJ       = rd_amr.o  rd_info.o  rd_part.o header.o utils.o Memory2.o find_leaf_gas.o rd_hydro.o rd_sink.o
+TIMEROBJ       = rd_amr.o  rd_info.o  rd_part.o header.o utils.o Memory2.o find_leaf_gas.o rd_hydro.o rd_sink.o rd_gadget.o
 
 NEWDD	= newdd.exe
 NEWDDOBJ	= newdd.o
 
-INCLUDES = -I./ -I../
-HDF5_DIR ?= /usr/local
-HDF5_INC = -I$(HDF5_DIR)/include
-HDF5_LIB = -L$(HDF5_DIR)/lib -lhdf5
+HDF5_INC = /home/bkoh/miniconda3/envs/pgalf/include
+HDF5_LIB = /home/kjhan/local/lib
 
-ifneq (,$(findstring -DGADGET_HDF5,$(OPT)))
-TIMEROBJ += rd_gadget.o
-INCLUDES += $(HDF5_INC)
-endif
+INCLUDES = -I./ -I../ -I$(HDF5_INC)
 
 default:
 	$(MAKE) $(LIBS)
@@ -55,10 +48,7 @@ $(LIBS): $(TIMEROBJ)
 	ar -rcv $@ $?
 	ranlib $@
 
-OSTLIB = -L. -lmyram  -L/home/kjhan/local/lib -lm
-ifneq (,$(findstring -DGADGET_HDF5,$(OPT)))
-OSTLIB += $(HDF5_LIB)
-endif
+OSTLIB = -L. -lmyram  -L$(HDF5_LIB) -lhdf5 -Wl,-rpath,$(HDF5_LIB) -lm
 
 %.c:
 	$(CC) $(CFLAGS) -c $*.c
diff --git a/NewDD/SWIFT.md b/NewDD/SWIFT.md
new file mode 100644
index 0000000..cfd1830
--- /dev/null
+++ b/NewDD/SWIFT.md
@@ -0,0 +1,86 @@
+# SWIFT Compatibility Changes (Stage 2–4)
+
+This document summarizes the raw code changes made to support SWIFT HDF5 snapshots and ensure consistent cosmology handling across NewDD (Stage 2), opFoF (Stage 3), gfind/galcenter (Stage 4).
+
+## 1) NewDD: GADGET/SWIFT HDF5 parsing and memory safety
+
+Files:
+- `NewDD/rd_gadget.c`
+- `NewDD/rd_gadget.h`
+- `NewDD/newdd.c`
+- `NewDD/Makefile`
+- `ramses.h`
+
+Changes and rationale:
+- **SWIFT header handling** (`NewDD/rd_gadget.c`):
+  - SWIFT stores some header arrays with 7 elements; GADGET expects 6. A 7‑element temporary buffer is now used for `NumPart_ThisFile` and `MassTable`, then copied into the 6‑element structures to avoid overflow.
+  - `Time` is interpreted differently in SWIFT. We now read `Scale-factor` when present and valid, and use it as `header.time`.
+  - `BoxSize` can be a 3‑element array in SWIFT. We read the array and use the first element.
+  - SWIFT stores physical unit system under `InternalCodeUnits`. We read `U_L/U_M/U_t` and derive velocity; this is required for consistent unit conversions.
+  - SWIFT can use different dataset names (e.g., `BirthScaleFactors`, `MetalMassFractions`, `Densities`, `InternalEnergies`, `SmoothingLengths`, `SubgridMasses`, `AccretionRates`). These are now supported as fallbacks.
+
+- **Velocity scaling** (`NewDD/rd_gadget.c`):
+  - GADGET stores `v_pec/sqrt(a)` while SWIFT stores physical peculiar velocities. We now scale by `sqrt(a)` only for GADGET; SWIFT uses unscaled values.
+
+- **Memory2 stack allocator safety** (`NewDD/rd_gadget.c` + `NewDD/newdd.c`):
+  - Temporary arrays are freed **before** storing `ram->gas`/`ram->sink` because the stack allocator can relocate memory during frees. This prevents stale pointers.
+  - `newdd.c` now frees in strict LIFO order (dm → sink → gas → particle) to keep Memory2’s stack consistent.
+
+- **Snapshot basename fallback** (`NewDD/newdd.c`):
+  - Added fallback to `snap_####` after `snapdir_####` and `snapshot_###` to match SWIFT file naming.
+
+- **Build changes** (`NewDD/Makefile` + `ramses.h`):
+  - `-DGADGET_HDF5` is always enabled and `rd_gadget.o` is included.
+  - HDF5 include/lib paths are set for the current environment.
+  - `ramses.h` now has include guards, `GadgetHeaderType.npart` is `int`, and a `is_swift` flag is added.
+
+## 2) Cosmology overrides for consistency
+
+Files:
+- `opFoF/opfof.c`
+- `NewGalFinder/gfind.c`
+- `GalCenter/galcenter.c`
+
+Changes and rationale:
+- SWIFT headers may contain inconsistent or unexpected cosmology values. The pipeline requires:
+  - `Omega_m = 0.3`
+  - `Omega_b = 0.049`
+  - `Omega_L = 0.7`
+  - `H0 = 67.11`
+- Each stage explicitly overwrites the read header values with the required parameters to keep FoF linking length, mass conversions, and centers consistent across stages.
+
+## 3) FoF robustness and modern toolchain fixes
+
+Files:
+- `opFoF/Treewalk.fof.ordered.c`
+- `opFoF/fof.h`
+- `opFoF/Rules.make`
+
+Changes and rationale:
+- **Missing file handling**: if `BottomFaceContactHalo` is missing, we create an empty placeholder and return gracefully instead of hard exiting.
+- **Boolean enum**: fix invalid YES/NO macro definition to a proper enum.
+- **Compiler updates**: switch to `mpiicx/mpiifx` and add `-fcommon` for modern toolchain compatibility.
+
+## 4) Galaxy finding robustness and diagnostics
+
+Files:
+- `NewGalFinder/gfind.c`
+- `NewGalFinder/subhaloden.mod6.c`
+- `NewGalFinder/tree.h`
+- `NewGalFinder/Makefile`
+
+Changes and rationale:
+- **Cosmology overrides** and safe handling of zero/invalid `Omega_m` when computing linking length.
+- **mpeak guardrails**: clamp negative/out‑of‑range `mpeak` in MPI receive path to avoid invalid array accesses.
+- **Null/empty guards** in `write_data` when no particles are present.
+- **finddenpeak diagnostics**: log counters for density‑threshold behavior and explicitly mark all particles as `NOT_HALO_MEMBER` when no core is found.
+- **Precision**: `HaloQ` mass fields upgraded to `double` to avoid precision loss in accumulation.
+- **Build**: `NCHEM=9`, `NDUST=4` enforced per requirement.
+
+## 5) Summary of Why These Changes Were Necessary
+
+- SWIFT HDF5 snapshot layouts, unit conventions, and dataset naming differ from legacy GADGET assumptions.
+- The Memory2 stack allocator requires strict LIFO freeing order; previous frees could leave dangling pointers.
+- Stage‑3/4 physics needs fixed cosmology parameters; relying on headers caused inconsistency.
+- Modern Intel toolchains require updated compiler names and `-fcommon` to link legacy code.
+
diff --git a/NewDD/newdd.c b/NewDD/newdd.c
index 9d7e00c..0b10f62 100755
--- a/NewDD/newdd.c
+++ b/NewDD/newdd.c
@@ -70,8 +70,11 @@ int main(int argc, char **argv){
 	if(rd_gadget_info(&ram, basename, 0) != 0){
 		sprintf(basename,"./snapshot_%03d", istep);
 		if(rd_gadget_info(&ram, basename, 0) != 0){
-			fprintf(stderr, "Failed to locate snapshot base for step %d\n", istep);
-			return 2;
+			sprintf(basename,"./snap_%04d", istep);
+			if(rd_gadget_info(&ram, basename, 0) != 0){
+				fprintf(stderr, "Failed to locate snapshot base for step %d\n", istep);
+				return 2;
+			}
 		}
 	}
 
@@ -88,26 +91,31 @@ int main(int argc, char **argv){
 	sinmul = 0;
 	printf("GADGET mode: reading base '%s' with %d file(s)\n", basename, ram.nfiles);
 	for(ifile=0;ifile<ram.nfiles;ifile++){
-		printf("P%d: Reading snapshot file index %d\n", myid, ifile);
+		printf("P%d: Reading snapshot file index %d\n", myid, ifile); fflush(stdout);
+		/* Allocations in order: particle, gas, sink */
 		rd_gadget_particles(&ram, basename, ifile);
+		printf("P%d: particles done npart=%d\n", myid, ram.npart); fflush(stdout);
 		rd_gadget_gas(&ram, basename, ifile);
+		printf("P%d: gas done ngas=%d\n", myid, ram.ngas); fflush(stdout);
 		rd_gadget_bh(&ram, basename, ifile);
+		printf("P%d: bh done nsink=%d\n", myid, ram.nsink); fflush(stdout);
 
+		/* SplitDump output — order of writing doesn't matter */
 		if(ram.ngas > 0 && ram.gas != NULL){
+			printf("P%d: qsort GAS %d\n", myid, ram.ngas); fflush(stdout);
 			qsort(ram.gas, ram.ngas, sizeof(GasType), gassortx);
+			printf("P%d: SplitDump GAS\n", myid); fflush(stdout);
 			SplitDump(&ram, ram.gas, ram.ngas, GAS, istep, ifile+1, sinmul, nsplit);
-			Free(ram.gas);
-			ram.gas = NULL;
-			ram.ngas = 0;
+			printf("P%d: GAS done\n", myid); fflush(stdout);
 		}
 
 #ifdef READ_SINK
 		if(ram.nsink > 0 && ram.sink != NULL){
+			printf("P%d: qsort SINK %d\n", myid, ram.nsink); fflush(stdout);
 			qsort(ram.sink, ram.nsink, sizeof(SinkType), sinksortx);
+			printf("P%d: SplitDump SINK\n", myid); fflush(stdout);
 			SplitDump(&ram, ram.sink, ram.nsink, SINK, istep, ifile+1, sinmul, nsplit);
-			Free(ram.sink);
-			ram.sink = NULL;
-			ram.nsink = 0;
+			printf("P%d: SINK done\n", myid); fflush(stdout);
 		}
 #endif
 
@@ -117,6 +125,8 @@ int main(int argc, char **argv){
 			size_t nstar = 0;
 			StarType *star;
 
+			/* dm is allocated on top of sink/gas/particle — freed first below */
+			printf("P%d: Malloc dm npart=%d\n", myid, ram.npart); fflush(stdout);
 			dm = (DmType*)Malloc(sizeof(DmType)*ram.npart, PPTR(dm));
 			for(i=0;i<(size_t)ram.npart;i++){
 				if((ram.particle)[i].family ==1) {
@@ -125,8 +135,10 @@ int main(int argc, char **argv){
 				}
 			}
 			if(ndm > 0){
+				printf("P%d: SplitDump DM %zu\n", myid, ndm); fflush(stdout);
 				qsort(dm, ndm, sizeof(DmType), dmsortx);
 				SplitDump(&ram, dm, (int)ndm, DM, istep, ifile+1, sinmul, nsplit);
+				printf("P%d: DM done\n", myid); fflush(stdout);
 			}
 
 			star = (StarType*)dm;
@@ -137,15 +149,22 @@ int main(int argc, char **argv){
 				}
 			}
 			if(nstar > 0){
+				printf("P%d: SplitDump STAR %zu\n", myid, nstar); fflush(stdout);
 				qsort(star, nstar, sizeof(StarType), starsortx);
 				SplitDump(&ram, star, (int)nstar, STAR, istep, ifile+1, sinmul, nsplit);
+				printf("P%d: STAR done\n", myid); fflush(stdout);
 			}
 
-			Free(dm);
-			Free(ram.particle);
-			ram.particle = NULL;
-			ram.npart = 0;
+			printf("P%d: Free dm\n", myid); fflush(stdout);
+			Free(dm);  /* dm is on top of the stack — free first */
 		}
+
+		/* Free in reverse allocation order (LIFO): sink → gas → particle */
+		printf("P%d: Free sink/gas/particle\n", myid); fflush(stdout);
+		if(ram.sink != NULL)     { Free(ram.sink);     ram.sink     = NULL; ram.nsink = 0; }
+		if(ram.gas != NULL)      { Free(ram.gas);       ram.gas      = NULL; ram.ngas  = 0; }
+		if(ram.particle != NULL) { Free(ram.particle);  ram.particle = NULL; ram.npart = 0; }
+
 		printf("Current memory stack %lld\n", CurMemStack());fflush(stdout);
 	}
 
diff --git a/NewDD/rd_gadget.c b/NewDD/rd_gadget.c
index 95f955a..f43e103 100644
--- a/NewDD/rd_gadget.c
+++ b/NewDD/rd_gadget.c
@@ -9,6 +9,7 @@
 
 #include "ramses.h"
 #include "Memory.h"
+#include "rd_gadget.h"
 
 #ifdef GADGET_HDF5
 
@@ -50,6 +51,16 @@ static int read_attr_int(hid_t obj_id, const char *name, int *value){
 	return 0;
 }
 
+static int read_attr_int_array(hid_t obj_id, const char *name, int *values){
+	hid_t attr_id;
+	if(!attr_exists(obj_id, name)) return -1;
+	attr_id = H5Aopen(obj_id, name, H5P_DEFAULT);
+	if(attr_id < 0) return -1;
+	H5Aread(attr_id, H5T_NATIVE_INT, values);
+	H5Aclose(attr_id);
+	return 0;
+}
+
 static int read_attr_ll_array(hid_t obj_id, const char *name, long long *values){
 	hid_t attr_id;
 	if(!attr_exists(obj_id, name)) return -1;
@@ -193,6 +204,28 @@ static size_t part_count_from_coords(hid_t file_id, const char *group_name){
 	return n;
 }
 
+int gadget_get_nfiles(char *basename){
+	char filename[512];
+	hid_t file_id, header_id;
+	int nfiles = 1;
+
+	if(open_snapshot_file(basename, 0, filename, sizeof(filename), &file_id) != 0)
+		return -1;
+
+	header_id = H5Gopen2(file_id, "Header", H5P_DEFAULT);
+	if(header_id >= 0){
+		read_attr_int(header_id, "NumFilesPerSnapshot", &nfiles);
+		H5Gclose(header_id);
+	}
+	H5Fclose(file_id);
+	if(nfiles < 1) nfiles = 1;
+	return nfiles;
+}
+
+int gadget_check_dataset(hid_t group_id, const char *name){
+	return dataset_exists(group_id, name);
+}
+
 void gadget_units(RamsesType *ram, GadgetHeaderType *header){
 	double a = header->time;
 	double h = header->hubble;
@@ -211,7 +244,9 @@ void gadget_units(RamsesType *ram, GadgetHeaderType *header){
 	ram->scale_m = header->unit_mass / Msun * h;
 	ram->scale_T2 = (gamma - 1.0) * (header->unit_velocity * header->unit_velocity) * mu * mH / kB;
 	ram->mpcscale_l = header->unit_length / Mpc * h;
-	ram->kmscale_v = header->unit_velocity / 1.0e5 * sqrt(a);
+	/* GADGET stores v_pec/sqrt(a); SWIFT stores physical peculiar velocity directly */
+	ram->kmscale_v = header->is_swift ? header->unit_velocity / 1.0e5
+	                                  : header->unit_velocity / 1.0e5 * sqrt(a);
 	ram->scale_Gyr = ram->scale_t / oneyear / 1.0e9;
 }
 
@@ -241,11 +276,34 @@ int rd_gadget_info(RamsesType *ram, char *basename, int ifile){
 		return -1;
 	}
 
-	read_attr_ll_array(header_id, "NumPart_ThisFile", header.npart);
-	read_attr_double_array(header_id, "MassTable", header.mass);
+	/* NumPart_ThisFile: GADGET=6×int32, SWIFT=7×int64 — read into 7-element buffer */
+	{
+		long long tmp_npart[7] = {0,0,0,0,0,0,0};
+		read_attr_ll_array(header_id, "NumPart_ThisFile", tmp_npart);
+		for(i=0;i<6;i++) header.npart[i] = (int)tmp_npart[i];
+	}
+	/* MassTable: SWIFT may have 7 elements — use temp buffer to avoid overflow */
+	{
+		double tmp_mass[8] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
+		read_attr_double_array(header_id, "MassTable", tmp_mass);
+		for(i=0;i<6;i++) header.mass[i] = tmp_mass[i];
+	}
+	/* Time/Scale-factor: GADGET uses "Time" as scale factor;
+	   SWIFT "Time" is an internal coordinate — use "Scale-factor" instead */
 	read_attr_double(header_id, "Time", &header.time);
+	{
+		double aexp_sw = 0.0;
+		if(read_attr_double(header_id, "Scale-factor", &aexp_sw) == 0
+		   && aexp_sw > 0.0 && aexp_sw <= 2.0)
+			header.time = aexp_sw;
+	}
 	read_attr_double(header_id, "Redshift", &header.redshift);
-	read_attr_double(header_id, "BoxSize", &header.boxsize);
+	/* BoxSize: scalar in GADGET, 3-element array in SWIFT */
+	{
+		double tmp_box[3] = {0.0, 0.0, 0.0};
+		read_attr_double_array(header_id, "BoxSize", tmp_box);
+		header.boxsize = tmp_box[0];
+	}
 	read_attr_int(header_id, "NumFilesPerSnapshot", &header.nfiles);
 	read_attr_double(header_id, "Omega0", &header.omega0);
 	read_attr_double(header_id, "OmegaLambda", &header.omegalambda);
@@ -254,11 +312,31 @@ int rd_gadget_info(RamsesType *ram, char *basename, int ifile){
 	read_attr_int(header_id, "Flag_Cooling", &header.flag_cooling);
 	read_attr_int(header_id, "Flag_StellarAge", &header.flag_stellarage);
 	read_attr_int(header_id, "Flag_Metals", &header.flag_metals);
+	/* Units: GADGET stores in Header; SWIFT uses InternalCodeUnits group */
 	read_attr_double(header_id, "UnitLength_in_cm", &header.unit_length);
 	read_attr_double(header_id, "UnitMass_in_g", &header.unit_mass);
 	read_attr_double(header_id, "UnitVelocity_in_cm_per_s", &header.unit_velocity);
 
 	H5Gclose(header_id);
+
+	/* SWIFT: read physical unit system from InternalCodeUnits group */
+	header.is_swift = 0;
+	if(H5Lexists(file_id, "InternalCodeUnits", H5P_DEFAULT) > 0){
+		hid_t units_id = H5Gopen2(file_id, "InternalCodeUnits", H5P_DEFAULT);
+		if(units_id >= 0){
+			double U_L = 0.0, U_M = 0.0, U_t = 0.0;
+			read_attr_double(units_id, "Unit length in cgs (U_L)", &U_L);
+			read_attr_double(units_id, "Unit mass in cgs (U_M)", &U_M);
+			read_attr_double(units_id, "Unit time in cgs (U_t)", &U_t);
+			H5Gclose(units_id);
+			if(U_L > 0.0 && U_M > 0.0 && U_t > 0.0){
+				header.unit_length   = U_L;
+				header.unit_mass     = U_M;
+				header.unit_velocity = U_L / U_t;
+				header.is_swift = 1;
+			}
+		}
+	}
 	H5Fclose(file_id);
 
 	if(header.nfiles < 1) header.nfiles = 1;
@@ -289,7 +367,7 @@ int rd_gadget_info(RamsesType *ram, char *basename, int ifile){
 int rd_gadget_particles(RamsesType *ram, char *basename, int ifile){
 	char filename[512];
 	hid_t file_id, header_id;
-	double mass_table[GADGET_NTYPE];
+	double mass_table[8];
 	size_t ndm, nstar, npart;
 	PmType *particle;
 	size_t ip, i;
@@ -297,7 +375,7 @@ int rd_gadget_particles(RamsesType *ram, char *basename, int ifile){
 	const int ptypes_star[1] = {4};
 	int it;
 
-	for(i=0;i<GADGET_NTYPE;i++) mass_table[i] = 0.0;
+	for(i=0;i<8;i++) mass_table[i] = 0.0;
 
 	if(open_snapshot_file(basename, ifile, filename, sizeof(filename), &file_id) != 0){
 		ERRORPRINT("Cannot open particle file from base '%s' at file %d\n", basename, ifile);
@@ -415,10 +493,14 @@ int rd_gadget_particles(RamsesType *ram, char *basename, int ifile){
 		else for(i=0;i<n;i++) m[i] = mass_table[ptype];
 		if(dataset_exists(gid, "StellarFormationTime"))
 			read_dataset_double_1d(gid, "StellarFormationTime", n, tform);
+		else if(dataset_exists(gid, "BirthScaleFactors"))
+			read_dataset_double_1d(gid, "BirthScaleFactors", n, tform);
 		else
 			for(i=0;i<n;i++) tform[i] = 0.0;
 		if(dataset_exists(gid, "Metallicity"))
 			read_dataset_first_component(gid, "Metallicity", n, zmet);
+		else if(dataset_exists(gid, "MetalMassFractions"))
+			read_dataset_first_component(gid, "MetalMassFractions", n, zmet);
 		else
 			for(i=0;i<n;i++) zmet[i] = 0.0;
 
@@ -455,12 +537,12 @@ int rd_gadget_particles(RamsesType *ram, char *basename, int ifile){
 int rd_gadget_gas(RamsesType *ram, char *basename, int ifile){
 	char filename[512];
 	hid_t file_id, header_id, gid;
-	double mass_table[GADGET_NTYPE];
+	double mass_table[8];
 	size_t n, i;
 	double *x,*y,*z,*vx,*vy,*vz,*m,*rho,*u,*hsml,*zmet;
 	GasType *gas;
 
-	for(i=0;i<GADGET_NTYPE;i++) mass_table[i] = 0.0;
+	for(i=0;i<8;i++) mass_table[i] = 0.0;
 
 	if(open_snapshot_file(basename, ifile, filename, sizeof(filename), &file_id) != 0){
 		ERRORPRINT("Cannot open gas file from base '%s' at file %d\n", basename, ifile);
@@ -500,16 +582,28 @@ int rd_gadget_gas(RamsesType *ram, char *basename, int ifile){
 	if(dataset_exists(gid, "Masses")) read_dataset_double_1d(gid, "Masses", n, m);
 	else for(i=0;i<n;i++) m[i] = mass_table[0];
 
-	if(dataset_exists(gid, "Density")) read_dataset_double_1d(gid, "Density", n, rho);
+	if(dataset_exists(gid, "Density"))
+		read_dataset_double_1d(gid, "Density", n, rho);
+	else if(dataset_exists(gid, "Densities"))
+		read_dataset_double_1d(gid, "Densities", n, rho);
 	else for(i=0;i<n;i++) rho[i] = 0.0;
 
-	if(dataset_exists(gid, "InternalEnergy")) read_dataset_double_1d(gid, "InternalEnergy", n, u);
+	if(dataset_exists(gid, "InternalEnergy"))
+		read_dataset_double_1d(gid, "InternalEnergy", n, u);
+	else if(dataset_exists(gid, "InternalEnergies"))
+		read_dataset_double_1d(gid, "InternalEnergies", n, u);
 	else for(i=0;i<n;i++) u[i] = 0.0;
 
-	if(dataset_exists(gid, "SmoothingLength")) read_dataset_double_1d(gid, "SmoothingLength", n, hsml);
+	if(dataset_exists(gid, "SmoothingLength"))
+		read_dataset_double_1d(gid, "SmoothingLength", n, hsml);
+	else if(dataset_exists(gid, "SmoothingLengths"))
+		read_dataset_double_1d(gid, "SmoothingLengths", n, hsml);
 	else for(i=0;i<n;i++) hsml[i] = 0.0;
 
-	if(dataset_exists(gid, "Metallicity")) read_dataset_first_component(gid, "Metallicity", n, zmet);
+	if(dataset_exists(gid, "Metallicity"))
+		read_dataset_first_component(gid, "Metallicity", n, zmet);
+	else if(dataset_exists(gid, "MetalMassFractions"))
+		read_dataset_first_component(gid, "MetalMassFractions", n, zmet);
 	else for(i=0;i<n;i++) zmet[i] = 0.0;
 
 	gas = (GasType*)Malloc(sizeof(GasType)*n, PPTR(gas));
@@ -529,11 +623,14 @@ int rd_gadget_gas(RamsesType *ram, char *basename, int ifile){
 		gas[i].fx = gas[i].fy = gas[i].fz = 0.0;
 	}
 
+	/* Free temporaries BEFORE saving to ram->gas: the stack allocator updates
+	   the local `gas` pointer (via PtrToVariable/memmove) as each temp is freed.
+	   Saving ram->gas after frees captures the correct final address. */
+	Free(zmet); Free(hsml); Free(u); Free(rho); Free(m); Free(vz); Free(vy); Free(vx); Free(z); Free(y); Free(x);
 	ram->gas = gas;
 	ram->ngas = (int)n;
 	ram->nleafcell = (int)n;
 
-	Free(zmet); Free(hsml); Free(u); Free(rho); Free(m); Free(vz); Free(vy); Free(vx); Free(z); Free(y); Free(x);
 	H5Gclose(gid);
 	H5Fclose(file_id);
 	return ram->ngas;
@@ -542,13 +639,13 @@ int rd_gadget_gas(RamsesType *ram, char *basename, int ifile){
 int rd_gadget_bh(RamsesType *ram, char *basename, int ifile){
 	char filename[512];
 	hid_t file_id, header_id, gid;
-	double mass_table[GADGET_NTYPE];
+	double mass_table[8];
 	size_t n, i;
 	double *x,*y,*z,*vx,*vy,*vz,*mbh,*mdot;
 	idtype *ids;
 	SinkType *sink;
 
-	for(i=0;i<GADGET_NTYPE;i++) mass_table[i] = 0.0;
+	for(i=0;i<8;i++) mass_table[i] = 0.0;
 
 	if(open_snapshot_file(basename, ifile, filename, sizeof(filename), &file_id) != 0){
 		ERRORPRINT("Cannot open BH file from base '%s' at file %d\n", basename, ifile);
@@ -584,11 +681,18 @@ int rd_gadget_bh(RamsesType *ram, char *basename, int ifile){
 	read_dataset_vec3(gid, "Velocities", n, vx, vy, vz);
 	read_dataset_ids(gid, "ParticleIDs", n, ids);
 
-	if(dataset_exists(gid, "BH_Mass")) read_dataset_double_1d(gid, "BH_Mass", n, mbh);
-	else if(dataset_exists(gid, "Masses")) read_dataset_double_1d(gid, "Masses", n, mbh);
+	if(dataset_exists(gid, "BH_Mass"))
+		read_dataset_double_1d(gid, "BH_Mass", n, mbh);
+	else if(dataset_exists(gid, "SubgridMasses"))
+		read_dataset_double_1d(gid, "SubgridMasses", n, mbh);
+	else if(dataset_exists(gid, "Masses"))
+		read_dataset_double_1d(gid, "Masses", n, mbh);
 	else for(i=0;i<n;i++) mbh[i] = mass_table[5];
 
-	if(dataset_exists(gid, "BH_Mdot")) read_dataset_double_1d(gid, "BH_Mdot", n, mdot);
+	if(dataset_exists(gid, "BH_Mdot"))
+		read_dataset_double_1d(gid, "BH_Mdot", n, mdot);
+	else if(dataset_exists(gid, "AccretionRates"))
+		read_dataset_double_1d(gid, "AccretionRates", n, mdot);
 	else for(i=0;i<n;i++) mdot[i] = 0.0;
 
 	sink = (SinkType*)Malloc(sizeof(SinkType)*n, PPTR(sink));
@@ -612,10 +716,11 @@ int rd_gadget_bh(RamsesType *ram, char *basename, int ifile){
 		sink[i].id = ids[i];
 	}
 
+	/* Free temporaries BEFORE saving to ram->sink (same LIFO pointer reason as rd_gadget_gas) */
+	Free(ids); Free(mdot); Free(mbh); Free(vz); Free(vy); Free(vx); Free(z); Free(y); Free(x);
 	ram->sink = sink;
 	ram->nsink = (int)n;
 
-	Free(ids); Free(mdot); Free(mbh); Free(vz); Free(vy); Free(vx); Free(z); Free(y); Free(x);
 	H5Gclose(gid);
 	H5Fclose(file_id);
 	return ram->nsink;
diff --git a/NewDD/rd_gadget.h b/NewDD/rd_gadget.h
new file mode 100644
index 0000000..af16326
--- /dev/null
+++ b/NewDD/rd_gadget.h
@@ -0,0 +1,28 @@
+#ifndef RD_GADGET_H
+#define RD_GADGET_H
+
+#ifdef GADGET_HDF5
+#include <hdf5.h>
+#include "ramses.h"
+
+/* GADGET particle type indices */
+#define GADGET_TYPE_GAS   0
+#define GADGET_TYPE_HALO  1
+#define GADGET_TYPE_DISK  2
+#define GADGET_TYPE_BULGE 3
+#define GADGET_TYPE_STAR  4
+#define GADGET_TYPE_BH    5
+
+/* Function prototypes */
+int rd_gadget_info(RamsesType *ram, char *basename, int ifile);
+int rd_gadget_particles(RamsesType *ram, char *basename, int ifile);
+int rd_gadget_gas(RamsesType *ram, char *basename, int ifile);
+int rd_gadget_bh(RamsesType *ram, char *basename, int ifile);
+void gadget_units(RamsesType *ram, GadgetHeaderType *header);
+
+/* Helper functions */
+int gadget_get_nfiles(char *basename);
+int gadget_check_dataset(hid_t group_id, const char *name);
+
+#endif /* GADGET_HDF5 */
+#endif /* RD_GADGET_H */
diff --git a/NewGalFinder/Makefile b/NewGalFinder/Makefile
index d1445a8..952f43a 100644
--- a/NewGalFinder/Makefile
+++ b/NewGalFinder/Makefile
@@ -26,7 +26,7 @@ INCLUDES = -I$(FFTW)/include
 
 DFLAGS = -DNMEG=90000L
 
-OPT = -g  -qopenmp -DINDEX -DVarPM   -DXYZDBL -DNENER=0 -DNPRE=8 -DREAD_SINK -DNCHEM=3 -DADV
+OPT = -g  -qopenmp -DINDEX -DVarPM   -DXYZDBL -DNENER=0 -DNPRE=8 -DREAD_SINK -DNCHEM=9 -DNDUST=4 -DADV
 
 FFLAGS = $(FDFLAGS) $(OPT)  -mcmodel=medium
 CFLAGS = $(DFLAGS)  $(OPT) $(INCLUDES)  -DDEBUG=1 -DLOG=1
diff --git a/NewGalFinder/gfind.c b/NewGalFinder/gfind.c
index 8f75b09..b29ce87 100755
--- a/NewGalFinder/gfind.c
+++ b/NewGalFinder/gfind.c
@@ -22,7 +22,13 @@ float m_tidal[NUM_MASS],r_tidal[NUM_MASS];
 FoFTPtlStruct *rbuffer;
 size_t nbuffer=3000000;
 
+#define REQUIRED_OMEGA_M 0.3f
+#define REQUIRED_OMEGA_B 0.049f
+#define REQUIRED_H0 67.11f
+#define REQUIRED_OMEGA_L 0.7f
+
 void FREAD(FoFTPtlStruct *p, HaloQ *haloq, FILE *fp, float omep){
+	const float omega_safe = (omep > 0.f) ? omep : REQUIRED_OMEGA_M;
 	size_t i;
 	if(haloq->np > nbuffer) {
 		rbuffer=(FoFTPtlStruct*)Realloc(rbuffer, sizeof(FoFTPtlStruct)*haloq->np);
@@ -46,7 +52,7 @@ void FREAD(FoFTPtlStruct *p, HaloQ *haloq, FILE *fp, float omep){
 		p->vy = dm[i].vy;
 		p->vz = dm[i].vz;
 		p->mass = dm[i].mass;
-		p->link02 =  0.2*pow(dm[i].mass/2.7755e11L/omep, 0.33333333333333333333L);
+		p->link02 =  0.2*pow(dm[i].mass/2.7755e11L/omega_safe, 0.33333333333333333333L);
 		(p++)->p.dm = dm[i];
 	}
 	fread(gas, sizeof(GasType), haloq->npgas,fp);
@@ -59,7 +65,7 @@ void FREAD(FoFTPtlStruct *p, HaloQ *haloq, FILE *fp, float omep){
 		p->vy = gas[i].vy;
 		p->vz = gas[i].vz;
 		p->mass = gas[i].mass;
-		p->link02 =  0.2*pow(gas[i].mass/2.7755e11L/omep, 0.33333333333333333333L);
+		p->link02 =  0.2*pow(gas[i].mass/2.7755e11L/omega_safe, 0.33333333333333333333L);
 		(p++)->p.gas = gas[i];
 	}
 	fread(sink, sizeof(SinkType), haloq->npsink,fp);
@@ -72,7 +78,7 @@ void FREAD(FoFTPtlStruct *p, HaloQ *haloq, FILE *fp, float omep){
 		p->vy = sink[i].vy;
 		p->vz = sink[i].vz;
 		p->mass = sink[i].mass;
-		p->link02 =  0.2*pow(sink[i].mass/2.7755e11L/omep, 0.33333333333333333333L);
+		p->link02 =  0.2*pow(sink[i].mass/2.7755e11L/omega_safe, 0.33333333333333333333L);
 		(p++)->p.sink = sink[i];
 	}
 	fread(star, sizeof(StarType), haloq->npstar,fp);
@@ -85,7 +91,7 @@ void FREAD(FoFTPtlStruct *p, HaloQ *haloq, FILE *fp, float omep){
 		p->vy = star[i].vy;
 		p->vz = star[i].vz;
 		p->mass = star[i].mass;
-		p->link02 =  0.2*pow(star[i].mass/2.7755e11L/omep, 0.33333333333333333333L);
+		p->link02 =  0.2*pow(star[i].mass/2.7755e11L/omega_safe, 0.33333333333333333333L);
 		(p++)->p.star = star[i];
 	}
 }
@@ -232,6 +238,10 @@ int main(int argc, char *argv[]) {
 			fread(&omep,sizeof(float),1,rhfp);
 			fread(&omepb,sizeof(float),1,rhfp);
 			fread(&omeplam,sizeof(float),1,rhfp);
+			omep = REQUIRED_OMEGA_M;
+			omepb = REQUIRED_OMEGA_B;
+			omeplam = REQUIRED_OMEGA_L;
+			hubble = REQUIRED_H0;
 			fread(&amax,sizeof(float),1,rhfp);
 			fread(&anow,sizeof(float),1,rhfp);
 			ng = nx;
@@ -427,6 +437,7 @@ int main(int argc, char *argv[]) {
 							MPI_Recv(ptl2halonum,rnp,MPI_INT,src, PT2H_TAG, MPI_COMM_WORLD,&cstatus);
 							MPI_Probe(src,MPEAK_TAG,MPI_COMM_WORLD,&cstatus);
 							MPI_Recv(&mpeak,1,MPI_INT,src,MPEAK_TAG, MPI_COMM_WORLD,&cstatus);
+							if(mpeak < 0 || mpeak > rnp) mpeak = 0;
 							write_data(rbp,ptl2halonum,rnp);
 #ifdef DEBUG
 //							printf("P0 %d received with mpeak=%d\n",rnp,mpeak);
@@ -464,6 +475,7 @@ int main(int argc, char *argv[]) {
 					MPI_Recv(ptl2halonum,rnp,MPI_INT,mstatus.MPI_SOURCE,PT2H_TAG, MPI_COMM_WORLD,&cstatus);
 					MPI_Probe(mstatus.MPI_SOURCE,MPEAK_TAG,MPI_COMM_WORLD, &cstatus);
 					MPI_Recv(&mpeak,1,MPI_INT,mstatus.MPI_SOURCE,MPEAK_TAG, MPI_COMM_WORLD,&cstatus);
+					if(mpeak < 0 || mpeak > rnp) mpeak = 0;
 					if(1) fprintf(stdout,"receiving from %d with %d particles : %lld : %lld\n",
 								mstatus.MPI_SOURCE,rnp,iii,shalonum); fflush(stdout);
 					write_data(rbp,ptl2halonum,rnp);
@@ -692,6 +704,10 @@ void write_data(FoFTPtlStruct *ssbp,lint *rptl2halonum,int rrnp){
 	int wnp;
 	int i,j,k;
 
+	if(rrnp <= 0 || ssbp == NULL || rptl2halonum == NULL) return;
+	if(wrp == NULL || wbp == NULL || wlist == NULL) return;
+	if(mpeak < 0 || mpeak > rrnp) mpeak = 0;
+
 	if (mpeak > 0)
 	{
 		HaloInfo hinfo;
diff --git a/NewGalFinder/subhaloden.mod6.c b/NewGalFinder/subhaloden.mod6.c
index 894d8b9..e05adf2 100755
--- a/NewGalFinder/subhaloden.mod6.c
+++ b/NewGalFinder/subhaloden.mod6.c
@@ -417,23 +417,28 @@ int finddenpeak(float *den,int numneigh,long long *neighbor,int np,
 		Coretype **Core, int jflag, SimpleBasicParticleType *bp){
 	Coretype *core = *Core;
 	long long i,j,k;
+	long long n_above = 0, n_reject_higher = 0, n_localmax = 0;
+	float peak_thr = PEAKTHRESHOLD;
 	float *me,*you;
 	int iflag;
 	numcore = 0;
 	DEBUGPRINT("Now before finddenpeak with %d particles with flag= %d\n", np,jflag);
 	if(jflag == 1){
 		for(i=0;i<np;i++){
-			if(den[i] > PEAKTHRESHOLD && bp[i].type == TYPE_STAR)
+			if(den[i] > peak_thr && bp[i].type == TYPE_STAR)
 			{
+				n_above ++;
 				iflag = 1;
 				k = i*numneigh;
 				for(j=0;j<numneigh;j++){
 					if(den[neighbor[k+j]] > den[i]) {
 						iflag = 0;
+						n_reject_higher ++;
 						break;
 					}
 				}
 				if(iflag == 1){
+					n_localmax ++;
 					core[numcore].peak = i;
 					core[numcore].cx = bp[i].x;
 					core[numcore].cy = bp[i].y;
@@ -454,17 +459,20 @@ int finddenpeak(float *den,int numneigh,long long *neighbor,int np,
 	}
 	else {
 		for(i=0;i<np;i++){
-			if(den[i] > PEAKTHRESHOLD)
+			if(den[i] > peak_thr)
 			{
+				n_above ++;
 				iflag = 1;
 				k = i*numneigh;
 				for(j=0;j<numneigh;j++){
 					if(den[neighbor[k+j]] > den[i]) {
 						iflag = 0;
+						n_reject_higher ++;
 						break;
 					}
 				}
 				if(iflag == 1){
+					n_localmax ++;
 					if(numcore >= MAXNUMCORE){
 						fprintf(stderr,"Error exceeding the number of cores: %d :: %lld   %d   \n", numcore, i, np);
 						exit(999);
@@ -486,6 +494,8 @@ int finddenpeak(float *den,int numneigh,long long *neighbor,int np,
 		}
 	}
 	DEBUGPRINT("Now before merging peak. numcore= %d\n", numcore);
+	LOGPRINT("FINDDENPEAK_DIAG jflag=%d np=%d peak_thr=%g above=%lld localmax=%lld reject_higher=%lld numcore=%d\n",
+			jflag, np, peak_thr, n_above, n_localmax, n_reject_higher, numcore);
 //	if(numcore > 10) numcore = MergingPeak(bp,np,core,numcore,0);
 	DEBUGPRINT("Now after merging peak\n");
 	return numcore;
@@ -2864,7 +2874,8 @@ int subhalo_den(FoFTPtlStruct *rbp, lint np,lint *p2halo){
 	float xmax,ymax,zmax;
 	long long *neighbor;
 	int NumNeighbor,numcore;
-	float dthreshold;
+	int star_num, use_all_path;
+	float dthreshold, star_mass;
 	float *density;
 	Kptype *kp,*skp,*tkp;
 	Coretype *core;
@@ -2882,8 +2893,11 @@ int subhalo_den(FoFTPtlStruct *rbp, lint np,lint *p2halo){
 	if(1){
 		mklocalize(bp,np,&xinit,&yinit, &zinit,&xmax,&ymax,&zmax);
 	}
+	star_num = findstarnum(bp,np);
+	star_mass = findstarmass(bp,np);
+	use_all_path = (star_num <= NUMNEIGHBOR || star_mass < MINSTELLARMASS);
 	{
-		if(findstarnum(bp,np)<= NUMNEIGHBOR || findstarmass(bp,np)<MINSTELLARMASS){
+		if(use_all_path){
 			/*
 			neighbor = (int*)Malloc(sizeof(int)*np*NumNeighbor,PPTR(neighbor));
 			density = (float*)Malloc(sizeof(float)*np,PPTR(density));
@@ -2918,6 +2932,9 @@ int subhalo_den(FoFTPtlStruct *rbp, lint np,lint *p2halo){
 #endif
 		}
 		DEBUGPRINT("density calculates\n");
+		LOGPRINT("SUBHALO_DIAG np=%lld star_num=%d star_mass=%g branch=%s numcore=%d\n",
+				(long long)np, star_num, star_mass,
+				use_all_path ? "TYPE_ALL" : "TYPE_STAR", numcore);
 	}
 	{
 		DEBUGPRINT("%d numcore detected\n",numcore);
@@ -2927,18 +2944,13 @@ int subhalo_den(FoFTPtlStruct *rbp, lint np,lint *p2halo){
 		wp = (WorkingParticle *)Malloc(sizeof(WorkingParticle)*np,PPTR(wp));
 	}
 	if(numcore == 0) {
-		/*
-#ifdef NOBACKGROUND
-		for(i=0;i<np;i++){
-			p2halo[i] = 0;
-		}
-#endif
-		Free(wp);Free(density);Free(neighbor);
-		Free(bp);
+		/* No density peak means no detected subhalo for this FoF halo. */
+		LOGPRINT("SUBHALO_ZERO_CORE np=%lld star_num=%d star_mass=%g low_star_num=%d low_star_mass=%d branch=%s\n",
+				(long long)np, star_num, star_mass,
+				(star_num <= NUMNEIGHBOR), (star_mass < MINSTELLARMASS),
+				use_all_path ? "TYPE_ALL" : "TYPE_STAR");
+		for(i=0;i<np;i++) p2halo[i] = NOT_HALO_MEMBER;
 		return 0;
-		*/
-		for(i=0;i<np;i++) p2halo[i] = 0;
-		return 1;
 	}
 renumcore :
 	if(numcore ==1) {
diff --git a/NewGalFinder/tree.h b/NewGalFinder/tree.h
index 18871fc..ea8ae31 100755
--- a/NewGalFinder/tree.h
+++ b/NewGalFinder/tree.h
@@ -55,7 +55,7 @@ typedef struct Box{
 typedef struct HaloQ{
     size_t np,npstar,npgas,npdm,npsink;
     POSTYPE x,y,z;
-    float mass, mstar,mgas,mdm,msink;
+    double mass, mstar,mgas,mdm,msink;
     float vx,vy,vz;
 }HaloQ;
 
diff --git a/opFoF/Rules.make b/opFoF/Rules.make
index 6eb02de..c1e2dfb 100755
--- a/opFoF/Rules.make
+++ b/opFoF/Rules.make
@@ -15,11 +15,11 @@ RANLIB = ranlib
 ####      KIAS PG Compiler                          #####
 #########################################################
 AR = ar rcv
-FC = mpiifc
-CC = mpiicc
-F90C = mpiifort
+FC = mpiifx
+CC = mpiicx
+F90C = mpiifx
 #OPT = -DPGCC -mcmodel=medium -tp nehalem-64 -fast -mp -fastsse
-OPT = -DINTEL -g
+OPT = -DINTEL -g -fcommon
 
 INCLUDES = 
 
diff --git a/opFoF/Treewalk.fof.ordered.c b/opFoF/Treewalk.fof.ordered.c
index 54737f3..62f69f2 100755
--- a/opFoF/Treewalk.fof.ordered.c
+++ b/opFoF/Treewalk.fof.ordered.c
@@ -553,9 +553,16 @@ void ReadBottomFaceContact(FoFTPtlStruct *p,size_t npread, particle *alinked,int
 //#endif
 
 	sprintf(infile,"./FoF_Garbage/Garb.%.5d/BottomFaceContactHalo.%.5d.%.5d.dat",nstep,src,nstep);
-	if((fp=fopen(infile,"r")) == NULL){
+	fp=fopen(infile,"rb");
+	if(fp == NULL){
+		fp=fopen(infile,"wb");
+		if(fp != NULL) fclose(fp);
+		fp=fopen(infile,"rb");
+	}
+	if(fp == NULL){
 		fprintf(stderr,"error opening %s\n",infile);
-		exit(0);
+		free(linked);
+		return;
 	}
 //#ifdef OLD
 	for(j=0;j<mid;j++){
diff --git a/opFoF/fof.h b/opFoF/fof.h
index ffb7692..7210541 100755
--- a/opFoF/fof.h
+++ b/opFoF/fof.h
@@ -15,11 +15,7 @@
 #else
 #	define POSTYPE float
 #endif
-/*
-enum boolean {YES=01, NO=02};
-#define YES '0'
-#define NO '1'
-*/
+enum boolean {NO=0, YES=1};
 typedef struct Box{
 	POSTYPE x,y,z;
 	POSTYPE width;
diff --git a/opFoF/opfof.c b/opFoF/opfof.c
index 1cb56a4..680d058 100755
--- a/opFoF/opfof.c
+++ b/opFoF/opfof.c
@@ -24,6 +24,17 @@
 #define MAXNFILE 100000
 #define NLEN 190
 
+#define REQUIRED_OMEGA_M 0.3f
+#define REQUIRED_OMEGA_B 0.049f
+#define REQUIRED_H0 67.11f
+
+static void apply_required_cosmology(RamsesType *sp){
+	sp->omega_m = REQUIRED_OMEGA_M;
+	sp->omega_b = REQUIRED_OMEGA_B;
+	sp->omega_l = 1.0f - REQUIRED_OMEGA_M;
+	sp->omega_k = 0.0f;
+	sp->H0 = REQUIRED_H0;
+}
 
 particle p;
 size_t readparticle(FoFTPtlStruct **,size_t ,int ,int ,int ,char *,int);
@@ -472,6 +483,8 @@ int main(int argc,char *argv[]){
 			kkk = 2;
 		}
 	}
+	apply_required_cosmology(&simpar);
+
 	size = simpar.boxlen_ini;
 	hubble = simpar.H0;
 	omep = simpar.omega_m;
diff --git a/ramses.h b/ramses.h
index 69fecb4..d7d9e38 100755
--- a/ramses.h
+++ b/ramses.h
@@ -1,4 +1,6 @@
 /* This is a header file to read RAMSES data in C. */
+#ifndef RAMSES_H
+#define RAMSES_H
 
 /* You have to read these lines carefully before running it */
 #define NDIM 3
@@ -237,7 +239,7 @@ typedef struct RamsesType{
 
 #ifdef GADGET_HDF5
 typedef struct GadgetHeaderType{
-	long long npart[6];
+	int npart[6];
 	double mass[6];
 	double time;
 	double redshift;
@@ -253,6 +255,7 @@ typedef struct GadgetHeaderType{
 	int flag_cooling;
 	int flag_stellarage;
 	int flag_metals;
+	int is_swift;
 }GadgetHeaderType;
 #endif
 
@@ -359,3 +362,5 @@ int starsortx(const void*, const void*);
 int dmsortx(const void*, const void*);
 void units(RamsesType *);
 void mkfolder(char *);
+
+#endif /* RAMSES_H */
-- 
2.47.1

